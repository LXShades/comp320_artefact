using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Impostify : MonoBehaviour
{
    [Header("Texture parameters")]
    public int renderTextureWidth = 256;
    public int renderTextureHeight = 256;

    public bool useBestFit = true;

    [Header("Testing")]
    public bool previewProjectionMatrix = false;
    public bool fillImpostorBackground = false;
    public bool holdSpaceForImpostor = false;

    public Shader materialShader;

    [HideInInspector] public bool isPendingRefresh = false;

    /** Reference to the impostor generated by this impostifier */
    GameObject impostor;

    /** Texture to be used to render the impostor */
    RenderTexture impostorTexture;
    
    /** Material onto which the impostor texture will be applied */
    Material impostorMaterial;

    /** The camera that snapshots the impostors. We only need one such camera in the scene */
    static Camera impostorCamera
    {
        get
        {
            if (_impostorCamera)
            {
                return _impostorCamera;
            }
            else
            {
                _impostorCamera = FindOrCreateImpostorCamera();
                return _impostorCamera;
            }
        }
    }
    static Camera _impostorCamera;

    Camera mainCamera;
    
    /** Expected position of the impostor */
    Vector3 impostorPosition;

    /** Physical radius of the object. This translates to the height of the impostor (rename?) */
    float impostorRadius;

    /** The current projection matrix used by the impostor camera. Only applies when useBestFit is true. */
    Matrix4x4 impostorProjectionMatrix;

    void Start()
    {
        mainCamera = Camera.main;
    }

    void Update()
    {
        if (Input.GetKey(KeyCode.Space) && useBestFit)
        {
            if (previewProjectionMatrix)
            {
                mainCamera.ResetProjectionMatrix();
                mainCamera.projectionMatrix = impostorProjectionMatrix;
            }
        }
        else
        {
            mainCamera.ResetProjectionMatrix();
        }

        if (isPendingRefresh || Input.GetKeyDown(KeyCode.Space))
        {
            RefreshImpostor();
        }

        if (holdSpaceForImpostor)
        {
            GetComponent<Renderer>().enabled = !Input.GetKey(KeyCode.Space);

            if (impostor)
            {
                impostor.GetComponent<Renderer>().enabled = Input.GetKey(KeyCode.Space);
            }
        }
        else
        {
            GetComponent<Renderer>().enabled = (impostor == null);
        }
    }

    void RefreshImpostor()
    {
        CleanupResources();

        // Create the render texture for the impostor
        if (!impostorTexture)
        {
            impostorTexture = new RenderTexture((int)renderTextureWidth, (int)renderTextureWidth, 16);
        }

        // Render the impostor
        PrepareImpostorCamera();
        RenderImpostor();

        // Create the impostor plane. useBestFit specifies whether we should use a screen-spanning impostor or a 
        impostor = GameObject.CreatePrimitive(PrimitiveType.Plane);
        impostor.isStatic = true;

        if (!useBestFit)
        {
            float planeSize = 60f;

            impostor.transform.position = mainCamera.transform.position + mainCamera.transform.forward * (planeSize / Mathf.Tan(Mathf.Deg2Rad * impostorCamera.fieldOfView * 0.5f) / 2);
            impostor.transform.localScale = new Vector3(mainCamera.aspect * planeSize * 0.1f, planeSize * 0.1f, planeSize * 0.1f);
            impostor.transform.rotation = Quaternion.LookRotation(-Vector3.up, mainCamera.transform.position - impostor.transform.position);
        }
        else
        {
            float planeSize = impostorRadius * 2;

            impostor.transform.position = impostorPosition;
            impostor.transform.localScale = new Vector3(mainCamera.aspect * planeSize * 0.1f, planeSize * 0.1f, planeSize * 0.1f);
            impostor.transform.rotation = Quaternion.LookRotation(-mainCamera.transform.up, -mainCamera.transform.forward);
        }

        // Update the material
        impostorMaterial = new Material(materialShader);

        impostorMaterial.SetFloat("_Cutoff", 0.99f);

        impostorMaterial.mainTexture = impostorTexture;

        impostor.GetComponent<MeshRenderer>().sharedMaterial = impostorMaterial;
        
    }

    void CleanupResources()
    {
        if (impostor)
        {
            impostor.active = false;
            GameObject.Destroy(impostor);

            if (impostorTexture)
            {
                impostorTexture.Release();
                impostorTexture = null;
            }

            impostorMaterial = null;
        }
    }

    public static Camera FindOrCreateImpostorCamera()
    {
        // Some references are lost during recompile, so do a quick search for one first
        GameObject foundCamera = GameObject.Find("_ImpostorCamera_");

        if (!foundCamera)
        {
            // Create it!
            GameObject cameraObject = new GameObject("_ImpostorCamera_", typeof(Camera));

            cameraObject.GetComponent<Camera>().enabled = false;
            return cameraObject.GetComponent<Camera>();
        }
        else
        {
            return foundCamera.GetComponent<Camera>();
        }
    }

    void PrepareImpostorCamera()
    {
        // Setup the impostor camera
        Camera camera = impostorCamera;

        camera.aspect = mainCamera.aspect;
        camera.fieldOfView = mainCamera.fieldOfView;
        camera.transform.position = mainCamera.transform.position;
        camera.transform.rotation = mainCamera.transform.rotation;
        camera.targetTexture = impostorTexture;

        if (useBestFit)
        {
            // Figure out how big the impostor will be and its plane scale, etc, and render to that size
            impostorPosition = GetComponent<MeshRenderer>().bounds.center;
            impostorRadius = GetComponent<MeshRenderer>().bounds.extents.magnitude / 2 * 1.1f;

            float impostorDepth = Vector3.Dot(impostorPosition - camera.transform.position, camera.transform.forward);
            float frustumWidthAtImpostorDepth = (impostorDepth * Mathf.Tan(Mathf.Deg2Rad * camera.fieldOfView * 0.5f)) * 2f * camera.aspect;
            float frustumHeightAtImpostorDepth = (impostorDepth * Mathf.Tan(Mathf.Deg2Rad * camera.fieldOfView * 0.5f)) * 2f;
            float impostorScreenSpaceRadius = impostorRadius / frustumHeightAtImpostorDepth;
            Vector2 screenSpacePosition = new Vector2();

            screenSpacePosition = new Vector2(
                Vector3.Dot(camera.transform.right, impostorPosition - camera.transform.position) / frustumWidthAtImpostorDepth * 2,
                Vector3.Dot(camera.transform.up, impostorPosition - camera.transform.position) / frustumHeightAtImpostorDepth * 2);

            camera.ResetProjectionMatrix();

            impostorProjectionMatrix = Matrix4x4.Scale(new Vector3(0.5f / (impostorRadius / frustumHeightAtImpostorDepth), 0.5f / (impostorRadius / frustumHeightAtImpostorDepth), 1))
                                     * Matrix4x4.Translate(new Vector3(-screenSpacePosition.x, -screenSpacePosition.y, 0))
                                     * camera.projectionMatrix;

            camera.projectionMatrix = impostorProjectionMatrix;
        }
        else
        {
            camera.ResetProjectionMatrix();
        }
    }

    void RenderImpostor()
    {
        Camera camera = impostorCamera;
        int oldLayer = gameObject.layer;

        // Clear the background pixels
        camera.clearFlags = CameraClearFlags.Color;
        camera.backgroundColor = fillImpostorBackground ? new Color(0, 0, 1) : new Color(0, 0, 0, 0);

        // Setup to render only this object
        gameObject.layer = 30;
        camera.cullingMask = 1<<gameObject.layer;
        GetComponent<Renderer>().enabled = true;

        // Render to the impostor
        camera.Render();
        camera.targetTexture = null;
        camera.enabled = false;

        // Done!
        gameObject.layer = oldLayer;
    }

    private void OnDrawGizmos()
    {
        Gizmos.color = new Color(0, 1, 0, 0.25f);
        Gizmos.DrawSphere(GetComponent<MeshRenderer>().bounds.center, GetComponent<MeshRenderer>().bounds.extents.magnitude / 2);
        Gizmos.color = new Color(1, 1, 0, 1);
        Gizmos.DrawWireSphere(GetComponent<MeshRenderer>().bounds.center, GetComponent<MeshRenderer>().bounds.extents.magnitude / 2);
    }
}
