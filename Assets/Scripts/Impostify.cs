using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Impostify : MonoBehaviour
{
    [Header("Texture parameters")]
    public int renderTextureWidth = 256;
    public int renderTextureHeight = 256;

    [Header("Testing")]
    public bool previewProjectionMatrix = false;
    public bool fillImpostorBackground = false;
    public bool holdSpaceForImpostor = false;
    public bool useOwnTexture = false;

    public Shader materialShader;

    [HideInInspector] public bool isPendingRefresh = false;

    /** Reference to the impostor generated by this impostifier */
    GameObject impostor;

    /** Texture to be used to render the impostor */
    ImpostorSurface impostorSurface;
    
    /** Material onto which the impostor texture will be applied */
    Material impostorMaterial;

    /** The camera that snapshots the impostors. We only need one such camera in the scene */
    static Camera impostorCamera
    {
        get
        {
            if (_impostorCamera)
            {
                return _impostorCamera;
            }
            else
            {
                _impostorCamera = FindOrCreateImpostorCamera();
                return _impostorCamera;
            }
        }
    }
    static Camera _impostorCamera;

    Camera mainCamera;
    
    /** Expected position of the impostor */
    Vector3 impostorPosition;

    /** Physical radius of the object. This translates to the height of the impostor (rename?) */
    float impostorRadius;

    /** The current projection matrix used by the impostor camera. Only applies when useBestFit is true. */
    Matrix4x4 impostorProjectionMatrix;

    /** The renderer associated with this object */
    Renderer myRenderer;
    Mesh myMesh;

    /** World-space bounds of this object */
    private Vector3 boundsCentre;
    private float boundsRadius;

    private void Awake()
    {
        RefreshRendererInfo();
    }

    void Start()
    {
        mainCamera = Camera.main;
    }

    void Update()
    {
        if (Input.GetKey(KeyCode.Space) && previewProjectionMatrix)
        {
            mainCamera.ResetProjectionMatrix();
            mainCamera.projectionMatrix = impostorProjectionMatrix;
        }
        else
        {
            mainCamera.ResetProjectionMatrix();
        }

        /*if (isPendingRefresh || Input.GetKeyDown(KeyCode.Space))
        {
            RegenerateImpostor();
        }*/

        if (holdSpaceForImpostor)
        {
            if (impostorSurface != null)
            {
                if (impostorSurface.batch)
                {
                    impostorSurface.batch.GetComponent<MeshRenderer>().enabled = Input.GetKey(KeyCode.Space);
                }
            }

            myRenderer.enabled = !Input.GetKey(KeyCode.Space);

            if (impostor)
            {
                impostor.GetComponent<Renderer>().enabled = Input.GetKey(KeyCode.Space);
            }
        }
        else
        {
            myRenderer.enabled = (impostor == null);
        }
    }

    public void RegenerateImpostor(ImpostorSurface texFrag = null)
    {
        if (!useOwnTexture && texFrag == null)
        {
            return; // we need a texture!
        }

        CleanupResources();

        if (useOwnTexture)
        {
            // Create the render texture for the impostor
            if (useOwnTexture && impostorSurface == null)
            {
                impostorSurface = new ImpostorSurface()
                {
                    texture = new RenderTexture(renderTextureWidth, renderTextureWidth, 16),
                    uvDimensions = new Rect(0, 0, 1, 1),
                    owner = this
                };
            }
        }
        else
        {
            if (texFrag == null)
            {
                // We have no texture!
                Debug.LogWarning("No tex fragment supplied to impostor with useOwnTexture=false!");
                return;
            }

            impostorSurface = texFrag;
        }

        // Render the impostor
        PrepareImpostorCamera();
        RenderImpostor();

        // Create or update the impostor plane
        float planeSize = impostorRadius * 2;

        if (texFrag == null)
        {
            impostor = new GameObject("Impostor", typeof(Impostor));
            impostor.isStatic = true;

            impostor.transform.position = impostorPosition;
            impostor.transform.localScale = new Vector3(mainCamera.aspect * planeSize * 0.1f, planeSize * 0.1f, planeSize * 0.1f);
            impostor.transform.rotation = Quaternion.LookRotation(-mainCamera.transform.up, -mainCamera.transform.forward);
            
            // Update the material
            impostorMaterial = new Material(materialShader);

            impostorMaterial.SetFloat("_Cutoff", 0.99f);
            impostorMaterial.mainTexture = impostorSurface.texture;

            impostor.GetComponent<MeshRenderer>().sharedMaterial = impostorMaterial;
        }
        else
        {
            texFrag.batch.SetPlane(texFrag.batchPlaneIndex, impostorPosition, mainCamera.transform.up * (planeSize/2), mainCamera.transform.right * (planeSize/2 * mainCamera.aspect), texFrag.uvDimensions);
        }
    }

    void CleanupResources()
    {
        if (impostor)
        {
            impostor.SetActive(false);
            GameObject.Destroy(impostor);

            if (impostorSurface != null && useOwnTexture)
            {
                impostorSurface.texture.Release();
                impostorSurface = null;
            }

            impostorMaterial = null;
        }
    }

    public static Camera FindOrCreateImpostorCamera()
    {
        // Some references are lost during recompile, so do a quick search for one first
        GameObject foundCamera = GameObject.Find("_ImpostorCamera_");

        if (!foundCamera)
        {
            // Create it!
            GameObject cameraObject = new GameObject("_ImpostorCamera_", typeof(Camera));

            cameraObject.GetComponent<Camera>().enabled = false;
            return cameraObject.GetComponent<Camera>();
        }
        else
        {
            return foundCamera.GetComponent<Camera>();
        }
    }

    void PrepareImpostorCamera()
    {
        // Setup the impostor camera
        Camera camera = impostorCamera;

        camera.aspect = mainCamera.aspect;
        camera.fieldOfView = mainCamera.fieldOfView;
        camera.transform.position = mainCamera.transform.position;
        camera.transform.rotation = mainCamera.transform.rotation;
        camera.targetTexture = impostorSurface.texture;
        camera.pixelRect = new Rect(impostorSurface.pixelDimensions.x, impostorSurface.pixelDimensions.y,
                                    impostorSurface.pixelDimensions.width, impostorSurface.pixelDimensions.height);

        // Figure out how big the impostor will be and its plane scale, etc, and render to match that area of the screen
        impostorPosition = boundsCentre;
        impostorRadius = boundsRadius;

        float impostorDepth = Vector3.Dot(impostorPosition - camera.transform.position, camera.transform.forward);
        float frustumWidthAtImpostorDepth = (impostorDepth * Mathf.Tan(Mathf.Deg2Rad * camera.fieldOfView * 0.5f)) * 2f * camera.aspect;
        float frustumHeightAtImpostorDepth = (impostorDepth * Mathf.Tan(Mathf.Deg2Rad * camera.fieldOfView * 0.5f)) * 2f;
        float impostorScreenSpaceRadius = impostorRadius / frustumHeightAtImpostorDepth;
        Vector2 screenSpacePosition = new Vector2();

        screenSpacePosition = new Vector2(
            Vector3.Dot(camera.transform.right, impostorPosition - camera.transform.position) / frustumWidthAtImpostorDepth * 2,
            Vector3.Dot(camera.transform.up, impostorPosition - camera.transform.position) / frustumHeightAtImpostorDepth * 2);

        camera.ResetProjectionMatrix();

        impostorProjectionMatrix = Matrix4x4.Scale(new Vector3(0.5f / (impostorRadius / frustumHeightAtImpostorDepth), 0.5f / (impostorRadius / frustumHeightAtImpostorDepth), 1))
                                    * Matrix4x4.Translate(new Vector3(-screenSpacePosition.x, -screenSpacePosition.y, 0))
                                    * camera.projectionMatrix;

        camera.projectionMatrix = impostorProjectionMatrix;
    }

    void RenderImpostor()
    {
        Camera camera = impostorCamera;
        int oldLayer = myRenderer.gameObject.layer;
        bool oldVisible = myRenderer.enabled;
        const int impostorLayer = 30;

        // Clear the background pixels
        camera.clearFlags = CameraClearFlags.SolidColor;
        camera.backgroundColor = fillImpostorBackground ? new Color(0, 0, 1) : new Color(0, 0, 0, 0);

        // Setup to render only this object
        camera.cullingMask = 1<<impostorLayer;
        myRenderer.gameObject.layer = impostorLayer;
        myRenderer.enabled = true;

        // Render to the impostor
        camera.Render();

        camera.targetTexture = null;
        camera.enabled = false;

        // Done!
        myRenderer.gameObject.layer = oldLayer;
        myRenderer.enabled = oldVisible;
    }

    void RefreshRendererInfo()
    {
        myRenderer = GetComponent<Renderer>();

        // try to get the highest LOD if myRenderer fails
        if (myRenderer == null)
        {
            LODGroup lods = GetComponent<LODGroup>();

            myRenderer = lods.GetLODs()[0].renderers[0];
        }

        myMesh = myRenderer.GetComponent<MeshFilter>()?.mesh;
        
        if (myRenderer)
        {
            Vector3[] vertices = myMesh.vertices;
            Vector3 centre = (myMesh.bounds.max + myMesh.bounds.min) / 2;
            float maxDistance = 0;

            for (int i = 0; i < vertices.Length; i++)
            {
                float distance = Vector3.Distance(vertices[i], centre);

                if (distance > maxDistance)
                {
                    maxDistance = distance;
                }
            }

            boundsCentre = transform.TransformPoint(centre);
            boundsRadius = maxDistance * Mathf.Max(transform.localScale.x, transform.localScale.y, transform.localScale.z);
        }
    }

    private void OnDrawGizmos()
    {
        // show renderer boundaries in the editor
        if (myRenderer == null)
        {
            RefreshRendererInfo();

            if (myRenderer == null)
            {
                return;
            }
        }

        Gizmos.color = new Color(0, 1, 0, 0.25f);
        Gizmos.DrawSphere(boundsCentre, boundsRadius);
        Gizmos.color = new Color(1, 1, 0, 1);
        Gizmos.DrawWireSphere(boundsCentre, boundsRadius);
    }
}
